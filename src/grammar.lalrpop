use std::str::FromStr;

use crate::ast::{JLisp, Expr};

grammar;

match {
    r#"'\\n'"#,
    r#"'\\t'"#,
    r#"'\\r'"#,
    r#"'\\\\"#,
    r#"'\''"#,
    r#"'\"'"#,
} else {
    r#"'[^\\'\n]'"#,
    _
}


pub JLisp: JLisp= {
  <expr:Expr*> => JLisp { exprs: expr }
}

pub Expr: Expr  =  {
  <n:Number> => Expr::Number(n),
  <f:Float> => Expr::Float(f),
  <s:Symbol> => Expr::Symbol(s),
  <s:Char> => Expr::Char(s),
  <s:String> => Expr::String(s),
  <s:Sexpr> => Expr::Sexpr(s),
  <q:List> => Expr::List(q),
  <c:Comment> => Expr::Comment(c),
}

Sexpr = {
  "(" <Expr*> ")"
}

List = {
  "[" <Expr*> "]"
}

Number: i32 = {
  r"-?[0-9]+" => i32::from_str(<>).unwrap(),
}


Float: f32 = {
  r"-?[0-9]+\.[0-9]+" => f32::from_str(<>).unwrap(),
}

String: String = {
  r#""[^"\n]*""# => <>[1..<>.len()-1].to_string()
}

Char: char = {
    r#"'\\n'"# => '\n',
    r#"'\\t'"# => '\t',
    r#"'\\r'"# => '\r',
    r#"'\\\\"# => '\\',
    r#"'\''"# => '\'',
    r#"'\"'"# => '"',
    r#"'[^\\'\n]'"# => {
        let s = <>;
        // Extract the character at index 1 (skipping the opening quote)
        s.chars().nth(1).unwrap() 
    }
}

Symbol: String = {
  r#"[a-zA-Z\-\+_/\\!&<=>\*\^\|\%]+"# => <>.to_owned()
}

Comment: String = {
  r#";.*"# => <>.to_owned()
}
